{
    "contents" : "#\n####################################################################################\n#                                                                                  #   \n# Autoregressive and multilayer perceptron artificial neural networks              # \n#                                                                                  #\n#                                                                                  #\n#                                                                                  #\n#                                                                                  #\n####################################################################################\n#\n.onAttach <- \nfunction(...)\n{\n    version = library(help = arnn)$info[[1]] \n    version = version[pmatch(\"Version\",version)]\n    um = strsplit(version, \" \")[[1]]\n    version = um[nchar(um) > 0][2]\n    #\n    cat(paste(\"This is arnn package\", version, \"\\n\"))\n}\n#\n.onLoad <- function(lib,pkg){ library.dynam(\"arnn\",\"arnn\") }\n#\n####################################################################################\n#\ncoef.arnn      <- function(object, ...) { object$par       }\nfitted.arnn    <- function(object, ...) { object$fitted    }\nresiduals.arnn <- function(object, ...) { object$residuals }\nlogLik.arnn    <- function(object, ...) { structure( object$loglik,df=length(object$par),class=\"logLik\") }\n#\nsummary.arnn   <- function(object, ...) \n{\n    require(forecast)\n    print(object) \n    cat(\"\\nIn-sample error measures:\\n\")\n    print(accuracy(object))\n}\n#\nprint.arnn <-\nfunction (x, ...) \n{\n    cat(paste(\"\\nMethod:\", x$method, \"\\n\\n\"))\n    cat(paste(\"Call:\\n\", deparse(x$call), \"\\n\\n\"))\n    cat(\"Parameters:\\n\\n\")\n    print(coef(x))\n    cat(\"\\n\\n\")\n    cat(\"Sigma^2 estimated as: \", as.character(x$sigma^2))\n    cat(\"\\n\\n\")\n    cat(\"LogL: \", as.character(x$loglik))\n    cat(\"\\n\\n\")\n    cat(\"Information Criteria:\\n\")\n    print(x$IC)\n    cat(\"\\n\\n\")\n}\n#----------------------------------------------------------------------------------#\narnn <-\nfunction(x, lags = NULL, isMLP = FALSE, H = 1, w.max = 1.0, restarts = 1, seed = NULL,\n    lambda = 0, model = NULL,  optim.control = list()) \n{    \n  #\n  ################################################################################\n  #                                                                              #\n  #                             Funciones auxiliares                             # \n  #                                                                              #\n\t################################################################################\n  #\n  lagvector <- function(x, lags) \t\n  {    \n\t\tz = embed(x, max(lags)+1)\n\t\treturn (z[,lags+1])\n  }\t\n\t#\n  #-------------------------------------------------------------------------------\n  #\t\n\tobject2par <- function(object) \n  {\n\t\tif (isMLP == TRUE)\n\t\t{\n\t\t\treturn(c( object$M, c(object$Wih), c(object$Wbh), c(object$Who), object$Wbo))\n\t\t}\n\t\treturn(c( object$M, c(object$Wio), c(object$Wih), c(object$Wbh), c(object$Who), object$Wbo))\n\t}\n\t#\n  #-------------------------------------------------------------------------------\n  #\t\n\tpar2object <- function(object, par) \n  {\n\t\tk = 2  \n    ###\n    object$M     = par[1]        \n    ###\n    if (isMLP == FALSE)\n    {\n      object$Wio = matrix( data = par[k:(k + object$nlags - 1)], \n                           nrow = object$nlags, \n                           ncol = 1)        \n      k          = k + object$nlags\n    }\n    else        \n    {\n      object$Wio = matrix( 0, nrow = object$nlags, ncol = 1)        \n    }        \n    ###\n    if( object$H > 0)\n    {\n      ###\n\t\t  object$Wih = matrix( data = par[k:(k + object$H * object$nlags - 1)], \n                         nrow = object$nlags, \n\t\t                     ncol = object$H)        \n\t\t  k          = k + object$H * object$nlags\n      ###\n\t\t  object$Wbh = matrix( data = par[k:(k+object$H-1)],\n                           nrow = object$H,\n                           ncol = 1)\n\t\t  k          = k + object$H\n\t\t  ###\n      object$Who = matrix( data = par[k:(k+object$H-1)],\n                           nrow = object$H,\n                           ncol = 1)\n\t\t  k          = k + object$H\n    }\n\t\t###\n    object$Wbo = par[k]\n    ###\n\t\treturn(object)\n\t}\n\t#\n  #-------------------------------------------------------------------------------\n  #\t\n\tfn.foptim = function(w) \n  {\n\t\tobject = par2object(object, w)\n\t\tobject = arnn(x = object$x, model = object)\t\t        \n\t\treturn((1 - object$lambda) * object$sigma ^ 2 + object$lambda * sum( abs(w[-1])))\t\t\n\t}\n\t#\n  ################################################################################\n\t#                                                                              #\n  #                            Cuerpo de la funcion                              # \n  #                                                                              #\n\t################################################################################\n  #\n  if (!exists(\".Random.seed\", envir = .GlobalEnv, inherits = FALSE)) { runif(1) }\n  if (is.null(seed)) \n  {\n    RNGstate <- get(\".Random.seed\", envir = .GlobalEnv)\n  }\n  else \n  {\n    R.seed <- get(\".Random.seed\", envir = .GlobalEnv)\n    set.seed(seed)\n    RNGstate <- structure(seed, kind = as.list(RNGkind()))\n    on.exit(assign(\".Random.seed\", R.seed, envir = .GlobalEnv))\n  }\n  #\n  #\n  #\n\tif (is.null(model)) \n  {\t\t\n\t\tobject = list( x = x, lags = lags, nlags = length(lags), \n                   maxlag = max(lags), call = match.call(),            \n                   method   = \"arnn\",             \n                   restarts = restarts,\n                   H        = H,                  # número de neuronas en la capa oculta\t\t\t\n                   lambda   = lambda,             # parámetro de regularización\n                   numpar   = 1 + 1 + 2 * H + length(lags) * H)  \n\t\t#\n    if( isMLP == FALSE )\n    {\n      object$numpar = object$numpar + object$nlags\n    }\n    #\n\t\tobject = structure(object, class = \"arnn\")\t\t\n\t\trunopt = TRUE \t\t\t\t\t\t\n\t\t#\n\t}\n  else\n  {\n\t\tobject      = model\n\t\tobject$x    = x\n\t\tobject$call = match.call()\n\t\trunopt      = FALSE\n\t}\n\t#\n  #--------------------------------------------------------------------------------\n  #\n\tX.lagged = lagvector(object$x, object$lags)\n  y = x[(max(object$lags)+1):length(x)]\n  L = nrow(X.lagged)\n\t#\n\t#--------------------------------------------------------------------------------\n\t# \n\tif (runopt == TRUE) \n  {\t\t\n    for( irestart in 1:restarts)\n    {\n      wopt = optim( par     = runif(object$numpar, min = -w.max, max = w.max), \n                    fn      = fn.foptim,\n                    method  = \"BFGS\", \n                    control = optim.control )\n                          \n      u =  fn.foptim(wopt$par)\n\n      if (irestart == 1 || u < u.opt )\n      {\n        w.gopt = wopt\n        u.opt  = u\n      }\n    }                 \n    object = par2object(object, w.gopt$par)        \n\t\t#\n    #----------------------------------------------------------------------------\n    #   \n    names(object$M   ) = \"M\"\n    names(object$Wbo ) = \"Wbo\"\n    names(object$Wio ) = paste(\"Wio[\", object$lags, \"]\", sep = \"\")\n    if(object$H > 0)\n    {\n      names(object$Wbh ) = paste(\"Wbh[\", 1:object$H,  \"]\", sep = \"\")\n      names(object$Who ) = paste(\"Who[\", 1:object$H,  \"]\", sep = \"\")\n      names(object$Wih ) = paste(\"Wih[\", \n                                 matrix( rep(1:object$nlags, object$H),  object$nlags, object$H), \n                                 \",\", \n                                 t(matrix( rep(1:object$H, object$nlags), object$H, object$nlags)), \n                                 \"]\", sep = \"\" )\n        \n      #\n      object$par = c( object$M, c(object$Wio), c(object$Wih), c(object$Wbh), \n                      c(object$Who), object$Wbo)\n    }\n    else\n    {\n      object$par = c( object$M, c(object$Wio), object$Wbo)\n    } \n\t}\n\t#\n\t#--------------------------------------------------------------------------------\n\t#\t\t\n  if( object$H > 0)\n  {\n\t  f = X.lagged %*% object$Wih + t(matrix(rep(object$Wbh, L), nrow = object$H, ncol = L))\n\t  f = (1 / (1 + exp(-f))) ^ object$M \t\t\n\t  f = f %*% object$Who + object$Wbo + X.lagged %*% object$Wio\n  }\n  else\n  {\n    f = object$Wbo + X.lagged %*% object$Wio\n  }\n\t#\n\t#--------------------------------------------------------------------------------\n\t#\t\t\n  response         = y\n  residuals        = y - f\n  object$sigma     = sqrt(sum(residuals ^ 2) / (length(residuals) - 1))\n  if(L >= object$maxlag)\n  {\n    object$loglik    = -0.5 * (L - object$maxlag) * (log(2 * pi) + log(object$sigma^2)) - \n                       0.5 * sum(residuals^2) / object$sigma^2\n    p                = 1 + object$nlags\n\t  N                = L - object$maxlag   \n    AK               = -2 * object$loglik  + 2 * object$numpar                                 \n    AKc              = -2 * object$loglik  + 2 * object$numpar * (N / (N - object$numpar - 1))\n    HQ               = -2 * object$loglik  + 2 * object$numpar * log(log(L - object$maxlag)) \n    SC               = -2 * object$loglik  +     object$numpar * log(N)              \n    object$IC        = c(AK, AKc, HQ, SC)\n    names(object$IC) = c(\"AK\", \"AKc\", \"HQ\", \"SC\")\n  }\n  else\n  {\n    object$loglik = AK = AKc = HQ = SC = NULL\n  }\n  #\n  #--------------------------------------------------------------------------------\n  #    \t\n  frequency        = attributes(object$x)$tsp[3]    \n\tstart            = attributes(object$x)$tsp[1] + object$maxlag / frequency    \n  object$response  = ts(response,  start = start, frequency = frequency)\n  object$fitted    = ts(f,         start = start, frequency = frequency)\n  object$residuals = ts(residuals, start = start, frequency = frequency)\n  #\n\treturn(object)\n}\n#----------------------------------------------------------------------------------#\nsimulate.arnn <-\nfunction (object, nsim = 1000, seed = NULL, h = length(object$x),  \n    bootstrap = FALSE, ...) \n{\n    #-------------------------------------------------------------------------------\n    if (!exists(\".Random.seed\", envir = .GlobalEnv, inherits = FALSE)) { runif(1) }\n    if (is.null(seed)) \n    {\n        RNGstate <- get(\".Random.seed\", envir = .GlobalEnv)\n    }\n    else \n    {\n        R.seed <- get(\".Random.seed\", envir = .GlobalEnv)\n        set.seed(seed)\n        RNGstate <- structure(seed, kind = as.list(RNGkind()))\n        on.exit(assign(\".Random.seed\", R.seed, envir = .GlobalEnv))\n    }\n    #-------------------------------------------------------------------------------\n    if (bootstrap) \n    {\n        e = matrix(sample(object$residuals, h * nsim, replace = TRUE), \n            nrow = h, ncol = nsim)\n    }\n    else \n    {\n        e = matrix(rnorm(h * nsim, 0, object$sigma), \n            nrow = h, ncol = nsim)\n    }\n    #-------------------------------------------------------------------------------\n    To = length(object$x)\n    s = matrix(NA, nrow = h, ncol = nsim)\n    #\n\tfor (iserie in 1:nsim) \n    {\n\t\tx.sim = c(object$x, rep(NULL, times = h))\n        #\n\t\tfor (k in 1:h) \n        {\n\t\t\tX = x.sim[(To + k) - object$lags]            \n\t\t\t#######################################################################\n\t\t\tf = matrix(NA, nrow = 1, ncol = object$H)\n\t\t\tfor(i in 1:object$H) {\n\t\t\t\tf[,i] = X %*% object$Wih[,i]+ object$Wbh[i]\n\t\t\t\tf[,i] = (1 / (1 + exp(-f[,i])))^object$M\n\t\t\t}\n\t\t\tf = f %*% object$Who + object$Wbo + X %*% object$Wio\n\t\t\t#######################################################################\n\t\t\tx.sim[To + k] = f + e[k, iserie]\n\t\t}\n\t\ts[, iserie] = x.sim[(To + 1):(To + h)]\n\t}\n\treturn(s)\n}\n#----------------------------------------------------------------------------------#\nforecast.arnn <-\nfunction (object, h = 10, level = c(80, 95), fan = FALSE, bootstrap = FALSE, \n    seed = 1234, npaths = 5000, ...) \n{\n    if (fan) \n        level <- seq(51, 99, by = 3)\n    else \n    {\n        if (min(level) > 0 & max(level) < 1) \n            level <- 100 * level\n        else if (min(level) < 0 | max(level) > 99.99) \n            stop(\"Confidence limit out of range\")\n    }\n    nconf = length(level)\n    lower = upper = matrix(NA, nrow = h, ncol = nconf)\n    m = rep(0, h)\n\t#######################################################################\n    paths = simulate(object = object, npaths = npaths, seed = seed, h = h, bootstrap = bootstrap)\n\t#######################################################################\n    for (k in 1:h) {\n        m[k] = quantile(paths[, k], 0.5)\n        lower[k, ] = quantile(paths[, k], (1 - level/100))\n        upper[k, ] = quantile(paths[, k], level/100)\n    }\n    colnames(lower) = colnames(upper) = paste(level, \"%\", sep = \"\")\n    #\n    #\n    #\n    result           = list()\n    result$model     = object\n    result$method    = object$method    \n    result$level     = level\n    result$x         = object$x\n    result$residuals = residuals(object)\n    result$fitted    = fitted(object)    \n    #\n    frequency        = attributes(object$x)$tsp[3]\n    start            = attributes(object$x)$tsp[1] + length(object$x)/frequency\n    result$mean      = ts(data = m, start = start, frequency = frequency)\n    result$lower     = ts(data = lower, start = start, frequency = frequency)\n    result$upper     = ts(data = upper, start = start, frequency = frequency)\n    #\n    result = structure(result, class = \"forecast\")\n    return(result)\n}\n#----------------------------------------------------------------------------------#\n\n#\n#### First 80 points are used to fit the model\n#x <- ts(WWWusage[1:80], s = 1, f = 1)\n#\n#### A mlp neural network is fitted\n#fit <- arnn(x=x, lags=1:4, isMLP=FALSE, H=2, w.max=1e-3,     \n#    restarts=10, seed = 1234, lambda=0, optim.control=list(maxit=200))\n#\n#### information about the fitted model\n#summary(fit)    \n#    \n#### in-sample errors    \n#accuracy(fit)\n#\n#### out-of-sample errors\n#fit1 <- arnn(x = WWWusage, model = fit)\n#accuracy( fitted(fit1)[76:96], WWWusage[81:100] )\n#\n#### one-step forecasts plot\n#plot(WWWusage)\n#lines(fitted(fit1), col = 'red')\n#grid()\n#\n#### multi-step forecast plot\n#plot(forecast(fit, h=20, level=90, fan=FALSE, bootstrap=FALSE, \n#    seed=1234, npaths=1000))\n#grid()\n#\n\n\n\n\n\n",
    "created" : 1441122616562.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "291129622",
    "id" : "DC9967B0",
    "lastKnownWriteTime" : 1441122347,
    "path" : "C:/Users/deybvagm/Downloads/arnn.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}